# cs-tech
- ## [학부 기록 참고](https://www.notion.so/CS-2fa13262bcc247589913e9c0ebc7bab2)

- ## [레퍼런스 참고](https://github.com/davJ-star/cs-tech/blob/main/reference.md)


[참고 블로그](https://github.com/davJ-star/tech-interview-for-developer)

## 웹 개발
[웹 참고](https://github.com/davJ-star/tech-interview-for-developer/tree/master/Web)
### 브라우저의 렌더링 원리: 
브라우저가 HTML, CSS, JavaScript를 해석하여 웹 페이지를 화면에 표시하는 과정을 설명해주세요. 렌더링 파이프라인의 주요 단계와 각 단계에서 발생하는 작업들을 자세히 설명해주세요.

### RESTful API의 개념과 설계 원칙: 
RESTful API란 무엇이며, 어떤 원칙을 기반으로 설계되는지 설명해주세요. RESTful API 설계 시 고려해야 할 주요 사항과 장점, 단점을 비교 설명해주세요.

### HTTP와 HTTPS의 차이점과 보안 관련 이슈: 
HTTP와 HTTPS의 차이점을 설명하고, HTTPS가 제공하는 보안 기능과 관련된 이슈들을 자세히 설명해주세요.

### 브라우저 저장소(LocalStorage, SessionStorage, Cookie)의 차이점: 
LocalStorage, SessionStorage, Cookie의 용도와 차이점을 설명하고, 각 저장소를 적절하게 사용하는 예시를 들어주세요.

### 크로스 오리진 리소스 공유(CORS)의 개념과 해결 방법: 
CORS란 무엇이며, 발생하는 이유와 해결 방법을 설명해주세요. CORS 설정 방법과 관련된 보안 문제점을 함께 설명해주세요.

### 프론트엔드 프레임워크(React, Vue, Angular 등)의 특징과 차이점: 
React, Vue, Angular와 같은 프론트엔드 프레임워크의 주요 특징과 차이점을 비교 설명하고, 각 프레임워크를 선택할 때 고려해야 할 요소들을 설명해주세요.

### 웹 성능 최적화 기법 (이미지 최적화, 코드 분할, 캐싱 등): 
웹 페이지 성능을 향상시키기 위한 다양한 최적화 기법들을 설명하고, 각 기법의 장단점과 적용 시 고려 사항을 설명해주세요. 실제 프로젝트에서 사용했던 웹 성능 최적화 경험을 공유해주세요.

## 백엔드 개발 (Java)
### Java의 메모리 관리 방식 (가비지 컬렉션): 
Java의 메모리 관리 방식인 가비지 컬렉션의 원리를 설명하고, 다양한 가비지 컬렉션 알고리즘과 각 알고리즘의 장단점을 비교 설명해주세요.

### 추상 클래스와 인터페이스의 차이점: 
추상 클래스와 인터페이스의 차이점을 설명하고, 각각의 사용 용도와 장단점을 비교 설명해주세요. 실제 코드 예시를 통해 설명해주세요.

### 스레드 안전성(Thread-safety)과 동기화 메커니즘: 
스레드 안전성의 개념과 스레드 안전성을 보장하기 위한 동기화 메커니즘들을 설명해주세요. Java에서 제공하는 다양한 동기화 메커니즘 (synchronized, Lock, Atomic 등)을 비교 설명하고, 실제 코드 예시를 통해 설명해주세요.

### Java 8 이후 추가된 주요 기능들 (람다식, 스트림 API 등): 
Java 8 이후 추가된 주요 기능들을 설명하고, 각 기능의 사용 용도와 장점을 설명해주세요. 실제 코드 예시를 통해 설명해주세요.

### Spring Framework의 핵심 개념 (IoC, DI, AOP): 
Spring Framework의 핵심 개념인 IoC, DI, AOP를 설명하고, 각 개념의 작동 원리와 장점을 설명해주세요. Spring Framework를 사용하여 개발한 프로젝트 경험을 공유해주세요.

## 데이터 구조와 알고리즘
### 시간 복잡도와 공간 복잡도의 개념과 중요성: 
시간 복잡도와 공간 복잡도의 개념을 설명하고, 알고리즘의 효율성을 평가하는 데 있어 중요성을 설명해주세요.

### 배열과 연결 리스트의 차이점과 각각의 장단점: 
배열과 연결 리스트의 차이점을 설명하고, 각 데이터 구조의 장단점을 비교 설명해주세요. 실제 사용 사례를 통해 설명해주세요.

### 스택과 큐의 특징과 실제 사용 사례: 
스택과 큐의 특징을 설명하고, 각 데이터 구조의 실제 사용 사례를 설명해주세요.

### 이진 탐색 트리의 특징과 균형 잡힌 트리의 필요성: 
이진 탐색 트리의 특징을 설명하고, 균형 잡힌 트리의 필요성을 설명해주세요. 균형 잡힌 트리를 구현하는 대표적인 알고리즘 (AVL 트리, Red-Black 트리)을 설명해주세요.

### 해시 테이블의 작동 원리와 충돌 해결 방법: 
해시 테이블의 작동 원리를 설명하고, 충돌 발생 시 해결 방법 (체이닝, 오픈 주소법)을 설명해주세요. 각 방법의 장단점을 비교 설명해주세요.


## 네트워크
### [HTTP & HTTPS](https://github.com/davJ-star/tech-interview-for-developer/blob/master/Computer%20Science/Network/HTTP%20%26%20HTTPS.md)
```
  HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재.
  HTTPS는 텍스트를 암호화한다. 인터넷 상에서 정보를 암호화하는 SSL 프로토콜(대칭키와 공개키 암호화 방식을 적절히 혼합하는 하이브리드방식으로!)
```

```paintext
  HTTPS 통신 흐름
    애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.
    
    신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다.
    
    CA란? : Certificate Authority로, 공개키를 저장해주는 신뢰성이 검증된 민간기업
    
    계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.
    
    A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.
    
    클라이언트가 main.html 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.
    
    CA 기업의 공개키는 브라우저가 이미 알고있다. (세계적으로 신뢰할 수 있는 기업으로 등록되어 있기 때문에, 브라우저가 인증서를 탐색하여 해독이 가능한 것)
    
    브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다.
    
    클라이언트가 A서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-secret-key 를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보냅니다.
    
    A서버는 암호화된 대칭키를 자신의 개인키로 복호화 하여 클라이언트와 동일한 대칭키를 획득합니다.
    
    클라이언트, 서버는 각각 pre-master-secret-key를 master-secret-key으로 만듭니다.
    
    master-secret-key 를 통해 session-key를 생성하고 이를 이용하여 대칭키 방식으로 통신합니다.
    
    각 통신이 종료될 때마다 session-key를 파기합니다.
    
    
    HTTPS도 무조건 안전한 것은 아니다. (신뢰받는 CA 기업이 아닌 자체 인증서 발급한 경우 등)
    
    이때는 HTTPS지만 브라우저에서 주의 요함, 안전하지 않은 사이트와 같은 알림으로 주의 받게 된다.

```
### TCP (흐름제어/혼잡제어)
```
네트워크 통신에서 신뢰적인 연결방식
TCP는 기본적으로 unreliable network에서, reliable network를 보장할 수 있도록 하는 프로토콜

reliable network를 보장한다는 것은 4가지 문제점 존재
- 손실 : packet이 손실될 수 있는 문제
- 순서 바뀜 : packet의 순서가 바뀌는 문제
- Congestion : 네트워크가 혼잡한 문제
- Overload : receiver가 overload 되는 문제
```

```
- 흐름제어 (endsystem 대 endsystem)
    송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
    Flow Control은 receiver가 packet을 지나치게 많이 받지 않도록 조절하는 것
    기본 개념은 receiver가 sender에게 현재 자신의 상태를 feedback 한다는 점
- 혼잡제어 : 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법
```

#### 전송의 전체 과정
```
전송의 전체 과정
응용 계층(Application Layer)에서 데이터를 전송할 때, 보내는 쪽(sender)의 애플리케이션(Application)은 소켓(Socket)에 데이터를 쓰게 됩니다.
이 데이터는 전송 계층(Transport Layer)으로 전달되어 세그먼트(Segment)라는 작은 단위로 나누어집니다.
전송 계층은 이 세그먼트를 네트워크 계층(Network Layer)에 넘겨줍니다.
전송된 데이터는 수신자(receiver) 쪽으로 전달되어, 수신자 쪽에서는 수신 버퍼(Receive Buffer)에 저장됩니다.
이때, 수신자 쪽에서는 수신 버퍼의 용량을 넘치게 하지 않도록 조절해야 합니다.
수신자 쪽에서는 자신의 수신 버퍼의 남은 용량을 상대방(sender)에게 알려주는데, 이를 "수신 윈도우(Receive Window)"라고 합니다.
송신자(sender)는 수신자의 수신 윈도우를 확인하여 수신자의 수신 버퍼 용량을 초과하지 않도록 데이터를 전송합니다.
이를 통해 데이터 전송 중에 수신 버퍼가 넘치는 현상을 방지하면서, 안정적인 데이터 전송을 보장합니다. 이를 "플로우 컨트롤(Flow Control)"이라고 합니다.
```

## 데이터베이스




## 운영체제



## 컴퓨터구조



## 보안
### 공개키 대칭키
```paintext
  SSL 탄생의 시초가 됨
  
  1. A가 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하고 B에게 보냄
  2. B는 암호문을 받고, 자신의 비밀키로 복호화함
  3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화하여 A에게 보냄
  4. A는 자신의 대칭키로 암호문을 복호화함
  5. 앞으로 이 대칭키로 암호화를 통신함
  즉, 대칭키를 주고받을 때만 공개키 암호화 방식을 사용하고 이후에는 계속 대칭키 암호화 방식으로 통신하는 것!
```


```paintext

```




## 최신 기술 트렌드
### 마이크로서비스 아키텍처의 장단점과 모놀리식 아키텍처와의 비교: 
마이크로서비스 아키텍처의 장단점을 설명하고, 모놀리식 아키텍처와 비교하여 차이점을 설명해주세요. 마이크로서비스 아키텍처를 적용한 프로젝트 경험을 공유해주세요.

### 컨테이너화 기술(Docker, Kubernetes 등)의 이점과 사용 경험:
Docker와 Kubernetes와 같은 컨테이너화 기술의 이점을 설명하고, 실제 프로젝트에서 컨테이너화 기술을 사용한 경험을 공유해주세요.

### 서버리스 컴퓨팅의 개념과 적용 사례: 
서버리스 컴퓨팅의 개념을 설명하고, 서버리스 컴퓨팅을 적용할 수 있는 적절한 사례를 설명해주세요.

### CI/CD 파이프라인 구축 경험과 그 중요성: 
CI/CD 파이프라인 구축 경험을 설명하고, CI/CD 파이프라인 구축의 중요성을 설명해주세요.

### 클라우드 서비스(AWS, Azure, GCP 등) 활용 경험과 장단점: 
AWS, Azure, GCP와 같은 클라우드 서비스를 사용한 경험을 설명하고, 각 서비스의 장단점을 비교 설명해주세요.

## 면접 준비 팁
위 질문들은 개발자의 기술적 지식뿐만 아니라 실제 문제 해결 능력과 최신 기술 트렌드에 대한 이해도를 평가하는 데 중점을 둡니다.
면접 준비 시 이러한 주제들에 대해 깊이 있는 이해와 실제 프로젝트 경험을 연결지어 설명할 수 있도록 준비하는 것이 중요합니다.
